#include "server.h"
#include "mongoose.h"

static const char header_html[] = "content-type: text/html\r\n";
static const char header_js[] = "content-type: text/javascript\r\n";
static const char header_css[] = "content-type: text/css\r\n";

static const char FourOhFour_html[] = "<!DOCTYPE html>\n<html>\n<head>\n<link rel=\"stylesheet\" href=\"main.css\">\n</head>\n<body>\n<h1>ERROR 404</h1>\nThe requested resource was not found.\n</body>\n</html>";

static const char index_html[] = "<!DOCTYPE html>\n<html>\n<head>\n<link rel=\"stylesheet\" href=\"main.css\">\n</head>\n<body>\n<h1>I am a headline made with HTML</h1>\n<h3 id=\"demo\" onclick=\"myFunction()\">Click me to change my color.</h3>\n<script src=\"main.js\"></script>\n</body>\n</html>";

static const char main_css[] = "body {\n\tfont-family: sans-serif;\n\ttext-align: center;\n\tpadding: 3rem;\n\tfont-size: 1.125rem;\n\tline-height: 1.5;\n\ttransition: all 725ms ease-in-out;\n}\n\nh1 {\n\tfont-size: 2rem;\n\tfont-weight: bolder;\n\tmargin-bottom: 1rem;\n}\n\np {\n\tmargin-bottom: 1rem;\n\tcolor: tomato;\n}\n";

static const char main_js[] = "function myFunction() {\n\tdocument.getElementById(\"demo\").style.color = \"red\";\n}\n\nurl = \"ws://\" + window.location.hostname +\":\" + window.location.port + \"/websocket\"\nwebSocket = new WebSocket(url);\n\nwebSocket.onopen = function (event) {\n\tconsole.log(\"Opened!\")\n\twebSocket.send(\"Here's some text that the server is urgently awaiting!\");\n};\n\nwebSocket.onmessage = function (event) {\n\tconsole.log(event.data);\n}";

static const char msgpack_js[] = "\u00ef\u00bb\u00bf(function () {\n\t\"use strict\";\n\n\t// Serializes a value to a MessagePack byte array.\n\t//\n\t// data: The value to serialize. This can be a scalar, array or object.\n\t// options: An object that defined additional options.\n\t// - multiple: Indicates whether multiple values in data are concatenated to multiple MessagePack arrays.\n\t// - invalidTypeReplacement: The value that is used to replace values of unsupported types, or a function that returns such a value, given the original value as parameter.\n\tfunction serialize(data, options) {\n\t\tif (options && options.multiple && !Array.isArray(data)) {\n\t\t\tthrow new Error(\"Invalid argument type: Expected an Array to serialize multiple values.\");\n\t\t}\n\t\tconst pow32 = 0x100000000;   // 2^32\n\t\tlet floatBuffer, floatView;\n\t\tlet array = new Uint8Array(128);\n\t\tlet length = 0;\n\n\t\tvar th = \"\";\n\t\tif(options && options.typeHint){\n\t\t\tth = options.typeHint;\n\t\t}\n\n\t\tif (options && options.multiple) {\n\t\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\t\tappend(data[i], false, th);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tappend(data, false, th);\n\t\t}\n\t\treturn array.subarray(0, length);\n\n\t\tfunction append(data, isReplacement, th) {\n\t\t\tswitch (typeof data) {\n\t\t\t\tcase \"undefined\":\n\t\t\t\t\tappendNull(data);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"boolean\":\n\t\t\t\t\tappendBoolean(data);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"number\":\n\t\t\t\t\tappendNumber(data, th);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"string\":\n\t\t\t\t\tappendString(data);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"object\":\n\t\t\t\t\tif (data === null)\n\t\t\t\t\t\tappendNull(data);\n\t\t\t\t\telse if (data instanceof Date)\n\t\t\t\t\t\tappendDate(data);\n\t\t\t\t\telse if (Array.isArray(data))\n\t\t\t\t\t\tappendArray(data);\n\t\t\t\t\telse if (data instanceof Uint8Array || data instanceof Uint8ClampedArray)\n\t\t\t\t\t\tappendBinArray(data);\n\t\t\t\t\telse if (data instanceof Int8Array || data instanceof Int16Array || data instanceof Uint16Array ||\n\t\t\t\t\t\tdata instanceof Int32Array || data instanceof Uint32Array ||\n\t\t\t\t\t\tdata instanceof Float32Array || data instanceof Float64Array)\n\t\t\t\t\t\tappendArray(data);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendObject(data);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (!isReplacement && options && options.invalidTypeReplacement) {\n\t\t\t\t\t\tif (typeof options.invalidTypeReplacement === \"function\")\n\t\t\t\t\t\t\tappend(options.invalidTypeReplacement(data), true, th);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tappend(options.invalidTypeReplacement, true, th);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new Error(\"Invalid argument type: The type '\" + (typeof data) + \"' cannot be serialized.\");\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction appendNull(data) {\n\t\t\tappendByte(0xc0);\n\t\t}\n\n\t\tfunction appendBoolean(data) {\n\t\t\tappendByte(data ? 0xc3 : 0xc2);\n\t\t}\n\n\t\tfunction appendNumber(data, th) {\n\t\t\tvar isInteger = (th === \"int\") ||\n\t\t\t\t\t\t\t(isFinite(data) && Math.floor(data) === data && th !== \"double\" && th !== \"float\");\n\t\t\tif (isInteger) {\n\t\t\t\t// Integer\n\t\t\t\tif (data >= 0 && data <= 0x7f) {\n\t\t\t\t\tappendByte(data);\n\t\t\t\t}\n\t\t\t\telse if (data < 0 && data >= -0x20) {\n\t\t\t\t\tappendByte(data);\n\t\t\t\t}\n\t\t\t\telse if (data > 0 && data <= 0xff) {   // uint8\n\t\t\t\t\tappendBytes([0xcc, data]);\n\t\t\t\t}\n\t\t\t\telse if (data >= -0x80 && data <= 0x7f) {   // int8\n\t\t\t\t\tappendBytes([0xd0, data]);\n\t\t\t\t}\n\t\t\t\telse if (data > 0 && data <= 0xffff) {   // uint16\n\t\t\t\t\tappendBytes([0xcd, data >>> 8, data]);\n\t\t\t\t}\n\t\t\t\telse if (data >= -0x8000 && data <= 0x7fff) {   // int16\n\t\t\t\t\tappendBytes([0xd1, data >>> 8, data]);\n\t\t\t\t}\n\t\t\t\telse if (data > 0 && data <= 0xffffffff) {   // uint32\n\t\t\t\t\tappendBytes([0xce, data >>> 24, data >>> 16, data >>> 8, data]);\n\t\t\t\t}\n\t\t\t\telse if (data >= -0x80000000 && data <= 0x7fffffff) {   // int32\n\t\t\t\t\tappendBytes([0xd2, data >>> 24, data >>> 16, data >>> 8, data]);\n\t\t\t\t}\n\t\t\t\telse if (data > 0 && data <= 0xffffffffffffffff) {   // uint64\n\t\t\t\t\t// Split 64 bit number into two 32 bit numbers because JavaScript only regards\n\t\t\t\t\t// 32 bits for bitwise operations.\n\t\t\t\t\tlet hi = data / pow32;\n\t\t\t\t\tlet lo = data % pow32;\n\t\t\t\t\tappendBytes([0xd3, hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);\n\t\t\t\t}\n\t\t\t\telse if (data >= -0x8000000000000000 && data <= 0x7fffffffffffffff) {   // int64\n\t\t\t\t\tappendByte(0xd3);\n\t\t\t\t\tappendInt64(data);\n\t\t\t\t}\n\t\t\t\telse if (data < 0) {   // below int64\n\t\t\t\t\tappendBytes([0xd3, 0x80, 0, 0, 0, 0, 0, 0, 0]);\n\t\t\t\t}\n\t\t\t\telse {   // above uint64\n\t\t\t\t\tappendBytes([0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Float\n\t\t\t\tif (!floatView) {\n\t\t\t\t\tfloatBuffer = new ArrayBuffer(8);\n\t\t\t\t\tfloatView = new DataView(floatBuffer);\n\t\t\t\t}\n\t\t\t\tfloatView.setFloat64(0, data);\n\t\t\t\tappendByte(0xcb);\n\t\t\t\tappendBytes(new Uint8Array(floatBuffer));\n\t\t\t}\n\t\t}\n\n\t\tfunction appendString(data) {\n\t\t\tlet bytes = encodeUtf8(data);\n\t\t\tlet length = bytes.length;\n\n\t\t\tif (length <= 0x1f)\n\t\t\t\tappendByte(0xa0 + length);\n\t\t\telse if (length <= 0xff)\n\t\t\t\tappendBytes([0xd9, length]);\n\t\t\telse if (length <= 0xffff)\n\t\t\t\tappendBytes([0xda, length >>> 8, length]);\n\t\t\telse\n\t\t\t\tappendBytes([0xdb, length >>> 24, length >>> 16, length >>> 8, length]);\n\n\t\t\tappendBytes(bytes);\n\t\t}\n\n\t\tfunction appendArray(data) {\n\t\t\tlet length = data.length;\n\n\t\t\tif (length <= 0xf)\n\t\t\t\tappendByte(0x90 + length);\n\t\t\telse if (length <= 0xffff)\n\t\t\t\tappendBytes([0xdc, length >>> 8, length]);\n\t\t\telse\n\t\t\t\tappendBytes([0xdd, length >>> 24, length >>> 16, length >>> 8, length]);\n\n\t\t\tfor (let index = 0; index < length; index++) {\n\t\t\t\tappend(data[index]);\n\t\t\t}\n\t\t}\n\n\t\tfunction appendBinArray(data) {\n\t\t\tlet length = data.length;\n\n\t\t\tif (length <= 0xf)\n\t\t\t\tappendBytes([0xc4, length]);\n\t\t\telse if (length <= 0xffff)\n\t\t\t\tappendBytes([0xc5, length >>> 8, length]);\n\t\t\telse\n\t\t\t\tappendBytes([0xc6, length >>> 24, length >>> 16, length >>> 8, length]);\n\n\t\t\tappendBytes(data);\n\t\t}\n\n\t\tfunction appendObject(data) {\n\t\t\tlet length = 0;\n\t\t\tfor (let key in data) {\n\t\t\t\tif (data[key] !== undefined) {\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (length <= 0xf)\n\t\t\t\tappendByte(0x80 + length);\n\t\t\telse if (length <= 0xffff)\n\t\t\t\tappendBytes([0xde, length >>> 8, length]);\n\t\t\telse\n\t\t\t\tappendBytes([0xdf, length >>> 24, length >>> 16, length >>> 8, length]);\n\n\t\t\tfor (let key in data) {\n\t\t\t\tlet value = data[key];\n\t\t\t\tif (value !== undefined) {\n\t\t\t\t\tappend(key);\n\t\t\t\t\tappend(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction appendDate(data) {\n\t\t\tlet sec = data.getTime() / 1000;\n\t\t\tif (data.getMilliseconds() === 0 && sec >= 0 && sec < 0x100000000) {   // 32 bit seconds\n\t\t\t\tappendBytes([0xd6, 0xff, sec >>> 24, sec >>> 16, sec >>> 8, sec]);\n\t\t\t}\n\t\t\telse if (sec >= 0 && sec < 0x400000000) {   // 30 bit nanoseconds, 34 bit seconds\n\t\t\t\tlet ns = data.getMilliseconds() * 1000000;\n\t\t\t\tappendBytes([0xd7, 0xff, ns >>> 22, ns >>> 14, ns >>> 6, ((ns << 2) >>> 0) | (sec / pow32), sec >>> 24, sec >>> 16, sec >>> 8, sec]);\n\t\t\t}\n\t\t\telse {   // 32 bit nanoseconds, 64 bit seconds, negative values allowed\n\t\t\t\tlet ns = data.getMilliseconds() * 1000000;\n\t\t\t\tappendBytes([0xc7, 12, 0xff, ns >>> 24, ns >>> 16, ns >>> 8, ns]);\n\t\t\t\tappendInt64(sec);\n\t\t\t}\n\t\t}\n\n\t\tfunction appendByte(byte) {\n\t\t\tif (array.length < length + 1) {\n\t\t\t\tlet newLength = array.length * 2;\n\t\t\t\twhile (newLength < length + 1)\n\t\t\t\t\tnewLength *= 2;\n\t\t\t\tlet newArray = new Uint8Array(newLength);\n\t\t\t\tnewArray.set(array);\n\t\t\t\tarray = newArray;\n\t\t\t}\n\t\t\tarray[length] = byte;\n\t\t\tlength++;\n\t\t}\n\n\t\tfunction appendBytes(bytes) {\n\t\t\tif (array.length < length + bytes.length) {\n\t\t\t\tlet newLength = array.length * 2;\n\t\t\t\twhile (newLength < length + bytes.length)\n\t\t\t\t\tnewLength *= 2;\n\t\t\t\tlet newArray = new Uint8Array(newLength);\n\t\t\t\tnewArray.set(array);\n\t\t\t\tarray = newArray;\n\t\t\t}\n\t\t\tarray.set(bytes, length);\n\t\t\tlength += bytes.length;\n\t\t}\n\n\t\tfunction appendInt64(value) {\n\t\t\t// Split 64 bit number into two 32 bit numbers because JavaScript only regards 32 bits for\n\t\t\t// bitwise operations.\n\t\t\tlet hi, lo;\n\t\t\tif (value >= 0) {\n\t\t\t\t// Same as uint64\n\t\t\t\thi = value / pow32;\n\t\t\t\tlo = value % pow32;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Split absolute value to high and low, then NOT and ADD(1) to restore negativity\n\t\t\t\tvalue++;\n\t\t\t\thi = Math.abs(value) / pow32;\n\t\t\t\tlo = Math.abs(value) % pow32;\n\t\t\t\thi = ~hi;\n\t\t\t\tlo = ~lo;\n\t\t\t}\n\t\t\tappendBytes([hi >>> 24, hi >>> 16, hi >>> 8, hi, lo >>> 24, lo >>> 16, lo >>> 8, lo]);\n\t\t}\n\t}\n\n\t// Deserializes a MessagePack byte array to a value.\n\t//\n\t// array: The MessagePack byte array to deserialize. This must be an Array or Uint8Array containing bytes, not a string.\n\t// options: An object that defined additional options.\n\t// - multiple: Indicates whether multiple concatenated MessagePack arrays are returned as an array.\n\tfunction deserialize(array, options) {\n\t\tconst pow32 = 0x100000000;   // 2^32\n\t\tlet pos = 0;\n\t\tif (array instanceof ArrayBuffer) {\n\t\t\tarray = new Uint8Array(array);\n\t\t}\n\t\tif (typeof array !== \"object\" || typeof array.length === \"undefined\") {\n\t\t\tthrow new Error(\"Invalid argument type: Expected a byte array (Array or Uint8Array) to deserialize.\");\n\t\t}\n\t\tif (!array.length) {\n\t\t\tthrow new Error(\"Invalid argument: The byte array to deserialize is empty.\");\n\t\t}\n\t\tif (!(array instanceof Uint8Array)) {\n\t\t\tarray = new Uint8Array(array);\n\t\t}\n\t\tlet data;\n\t\tif (options && options.multiple) {\n\t\t\t// Read as many messages as are available\n\t\t\tdata = [];\n\t\t\twhile (pos < array.length) {\n\t\t\t\tdata.push(read());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Read only one message and ignore additional data\n\t\t\tdata = read();\n\t\t}\n\t\treturn data;\n\n\t\tfunction read() {\n\t\t\tconst byte = array[pos++];\n\t\t\tif (byte >= 0x00 && byte <= 0x7f) return byte;   // positive fixint\n\t\t\tif (byte >= 0x80 && byte <= 0x8f) return readMap(byte - 0x80);   // fixmap\n\t\t\tif (byte >= 0x90 && byte <= 0x9f) return readArray(byte - 0x90);   // fixarray\n\t\t\tif (byte >= 0xa0 && byte <= 0xbf) return readStr(byte - 0xa0);   // fixstr\n\t\t\tif (byte === 0xc0) return null;   // nil\n\t\t\tif (byte === 0xc1) throw new Error(\"Invalid byte code 0xc1 found.\");   // never used\n\t\t\tif (byte === 0xc2) return false;   // false\n\t\t\tif (byte === 0xc3) return true;   // true\n\t\t\tif (byte === 0xc4) return readBin(-1, 1);   // bin 8\n\t\t\tif (byte === 0xc5) return readBin(-1, 2);   // bin 16\n\t\t\tif (byte === 0xc6) return readBin(-1, 4);   // bin 32\n\t\t\tif (byte === 0xc7) return readExt(-1, 1);   // ext 8\n\t\t\tif (byte === 0xc8) return readExt(-1, 2);   // ext 16\n\t\t\tif (byte === 0xc9) return readExt(-1, 4);   // ext 32\n\t\t\tif (byte === 0xca) return readFloat(4);   // float 32\n\t\t\tif (byte === 0xcb) return readFloat(8);   // float 64\n\t\t\tif (byte === 0xcc) return readUInt(1);   // uint 8\n\t\t\tif (byte === 0xcd) return readUInt(2);   // uint 16\n\t\t\tif (byte === 0xce) return readUInt(4);   // uint 32\n\t\t\tif (byte === 0xcf) return readUInt(8);   // uint 64\n\t\t\tif (byte === 0xd0) return readInt(1);   // int 8\n\t\t\tif (byte === 0xd1) return readInt(2);   // int 16\n\t\t\tif (byte === 0xd2) return readInt(4);   // int 32\n\t\t\tif (byte === 0xd3) return readInt(8);   // int 64\n\t\t\tif (byte === 0xd4) return readExt(1);   // fixext 1\n\t\t\tif (byte === 0xd5) return readExt(2);   // fixext 2\n\t\t\tif (byte === 0xd6) return readExt(4);   // fixext 4\n\t\t\tif (byte === 0xd7) return readExt(8);   // fixext 8\n\t\t\tif (byte === 0xd8) return readExt(16);   // fixext 16\n\t\t\tif (byte === 0xd9) return readStr(-1, 1);   // str 8\n\t\t\tif (byte === 0xda) return readStr(-1, 2);   // str 16\n\t\t\tif (byte === 0xdb) return readStr(-1, 4);   // str 32\n\t\t\tif (byte === 0xdc) return readArray(-1, 2);   // array 16\n\t\t\tif (byte === 0xdd) return readArray(-1, 4);   // array 32\n\t\t\tif (byte === 0xde) return readMap(-1, 2);   // map 16\n\t\t\tif (byte === 0xdf) return readMap(-1, 4);   // map 32\n\t\t\tif (byte >= 0xe0 && byte <= 0xff) return byte - 256;   // negative fixint\n\t\t\tconsole.debug(\"msgpack array:\", array);\n\t\t\tthrow new Error(\"Invalid byte value '\" + byte + \"' at index \" + (pos - 1) + \" in the MessagePack binary data (length \" + array.length + \"): Expecting a range of 0 to 255. This is not a byte array.\");\n\t\t}\n\n\t\tfunction readInt(size) {\n\t\t\tlet value = 0;\n\t\t\tlet first = true;\n\t\t\twhile (size-- > 0) {\n\t\t\t\tif (first) {\n\t\t\t\t\tlet byte = array[pos++];\n\t\t\t\t\tvalue += byte & 0x7f;\n\t\t\t\t\tif (byte & 0x80) {\n\t\t\t\t\t\tvalue -= 0x80;   // Treat most-significant bit as -2^i instead of 2^i\n\t\t\t\t\t}\n\t\t\t\t\tfirst = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvalue *= 256;\n\t\t\t\t\tvalue += array[pos++];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tfunction readUInt(size) {\n\t\t\tlet value = 0;\n\t\t\twhile (size-- > 0) {\n\t\t\t\tvalue *= 256;\n\t\t\t\tvalue += array[pos++];\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tfunction readFloat(size) {\n\t\t\tlet view = new DataView(array.buffer, pos + array.byteOffset, size);\n\t\t\tpos += size;\n\t\t\tif (size === 4)\n\t\t\t\treturn view.getFloat32(0, false);\n\t\t\tif (size === 8)\n\t\t\t\treturn view.getFloat64(0, false);\n\t\t}\n\n\t\tfunction readBin(size, lengthSize) {\n\t\t\tif (size < 0) size = readUInt(lengthSize);\n\t\t\tlet data = array.subarray(pos, pos + size);\n\t\t\tpos += size;\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction readMap(size, lengthSize) {\n\t\t\tif (size < 0) size = readUInt(lengthSize);\n\t\t\tlet data = {};\n\t\t\twhile (size-- > 0) {\n\t\t\t\tlet key = read();\n\t\t\t\tdata[key] = read();\n\t\t\t}\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction readArray(size, lengthSize) {\n\t\t\tif (size < 0) size = readUInt(lengthSize);\n\t\t\tlet data = [];\n\t\t\twhile (size-- > 0) {\n\t\t\t\tdata.push(read());\n\t\t\t}\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction readStr(size, lengthSize) {\n\t\t\tif (size < 0) size = readUInt(lengthSize);\n\t\t\tlet start = pos;\n\t\t\tpos += size;\n\t\t\treturn decodeUtf8(array, start, size);\n\t\t}\n\n\t\tfunction readExt(size, lengthSize) {\n\t\t\tif (size < 0) size = readUInt(lengthSize);\n\t\t\tlet type = readUInt(1);\n\t\t\tlet data = readBin(size);\n\t\t\tswitch (type) {\n\t\t\t\tcase 255:\n\t\t\t\t\treturn readExtDate(data);\n\t\t\t}\n\t\t\treturn { type: type, data: data };\n\t\t}\n\n\t\tfunction readExtDate(data) {\n\t\t\tif (data.length === 4) {\n\t\t\t\tlet sec = ((data[0] << 24) >>> 0) +\n\t\t\t\t\t((data[1] << 16) >>> 0) +\n\t\t\t\t\t((data[2] << 8) >>> 0) +\n\t\t\t\t\tdata[3];\n\t\t\t\treturn new Date(sec * 1000);\n\t\t\t}\n\t\t\tif (data.length === 8) {\n\t\t\t\tlet ns = ((data[0] << 22) >>> 0) +\n\t\t\t\t\t((data[1] << 14) >>> 0) +\n\t\t\t\t\t((data[2] << 6) >>> 0) +\n\t\t\t\t\t(data[3] >>> 2);\n\t\t\t\tlet sec = ((data[3] & 0x3) * pow32) +\n\t\t\t\t\t((data[4] << 24) >>> 0) +\n\t\t\t\t\t((data[5] << 16) >>> 0) +\n\t\t\t\t\t((data[6] << 8) >>> 0) +\n\t\t\t\t\tdata[7];\n\t\t\t\treturn new Date(sec * 1000 + ns / 1000000);\n\t\t\t}\n\t\t\tif (data.length === 12) {\n\t\t\t\tlet ns = ((data[0] << 24) >>> 0) +\n\t\t\t\t\t((data[1] << 16) >>> 0) +\n\t\t\t\t\t((data[2] << 8) >>> 0) +\n\t\t\t\t\tdata[3];\n\t\t\t\tpos -= 8;\n\t\t\t\tlet sec = readInt(8);\n\t\t\t\treturn new Date(sec * 1000 + ns / 1000000);\n\t\t\t}\n\t\t\tthrow new Error(\"Invalid data length for a date value.\");\n\t\t}\n\t}\n\n\t// Encodes a string to UTF-8 bytes.\n\tfunction encodeUtf8(str) {\n\t\t// Prevent excessive array allocation and slicing for all 7-bit characters\n\t\tlet ascii = true, length = str.length;\n\t\tfor (let x = 0; x < length; x++) {\n\t\t\tif (str.charCodeAt(x) > 127) {\n\t\t\t\tascii = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Based on: https://gist.github.com/pascaldekloe/62546103a1576803dade9269ccf76330\n\t\tlet i = 0, bytes = new Uint8Array(str.length * (ascii ? 1 : 4));\n\t\tfor (let ci = 0; ci !== length; ci++) {\n\t\t\tlet c = str.charCodeAt(ci);\n\t\t\tif (c < 128) {\n\t\t\t\tbytes[i++] = c;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (c < 2048) {\n\t\t\t\tbytes[i++] = c >> 6 | 192;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c > 0xd7ff && c < 0xdc00) {\n\t\t\t\t\tif (++ci >= length)\n\t\t\t\t\t\tthrow new Error(\"UTF-8 encode: incomplete surrogate pair\");\n\t\t\t\t\tlet c2 = str.charCodeAt(ci);\n\t\t\t\t\tif (c2 < 0xdc00 || c2 > 0xdfff)\n\t\t\t\t\t\tthrow new Error(\"UTF-8 encode: second surrogate character 0x\" + c2.toString(16) + \" at index \" + ci + \" out of range\");\n\t\t\t\t\tc = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n\t\t\t\t\tbytes[i++] = c >> 18 | 240;\n\t\t\t\t\tbytes[i++] = c >> 12 & 63 | 128;\n\t\t\t\t}\n\t\t\t\telse bytes[i++] = c >> 12 | 224;\n\t\t\t\tbytes[i++] = c >> 6 & 63 | 128;\n\t\t\t}\n\t\t\tbytes[i++] = c & 63 | 128;\n\t\t}\n\t\treturn ascii ? bytes : bytes.subarray(0, i);\n\t}\n\n\t// Decodes a string from UTF-8 bytes.\n\tfunction decodeUtf8(bytes, start, length) {\n\t\t// Based on: https://gist.github.com/pascaldekloe/62546103a1576803dade9269ccf76330\n\t\tlet i = start, str = \"\";\n\t\tlength += start;\n\t\twhile (i < length) {\n\t\t\tlet c = bytes[i++];\n\t\t\tif (c > 127) {\n\t\t\t\tif (c > 191 && c < 224) {\n\t\t\t\t\tif (i >= length)\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 2-byte sequence\");\n\t\t\t\t\tc = (c & 31) << 6 | bytes[i++] & 63;\n\t\t\t\t}\n\t\t\t\telse if (c > 223 && c < 240) {\n\t\t\t\t\tif (i + 1 >= length)\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 3-byte sequence\");\n\t\t\t\t\tc = (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;\n\t\t\t\t}\n\t\t\t\telse if (c > 239 && c < 248) {\n\t\t\t\t\tif (i + 2 >= length)\n\t\t\t\t\t\tthrow new Error(\"UTF-8 decode: incomplete 4-byte sequence\");\n\t\t\t\t\tc = (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;\n\t\t\t\t}\n\t\t\t\telse throw new Error(\"UTF-8 decode: unknown multibyte start 0x\" + c.toString(16) + \" at index \" + (i - 1));\n\t\t\t}\n\t\t\tif (c <= 0xffff) str += String.fromCharCode(c);\n\t\t\telse if (c <= 0x10ffff) {\n\t\t\t\tc -= 0x10000;\n\t\t\t\tstr += String.fromCharCode(c >> 10 | 0xd800)\n\t\t\t\tstr += String.fromCharCode(c & 0x3FF | 0xdc00)\n\t\t\t}\n\t\t\telse throw new Error(\"UTF-8 decode: code point 0x\" + c.toString(16) + \" exceeds UTF-16 reach\");\n\t\t}\n\t\treturn str;\n\t}\n\n\t// The exported functions\n\tlet msgpack = {\n\t\tserialize: serialize,\n\t\tdeserialize: deserialize,\n\n\t\t// Compatibility with other libraries\n\t\tencode: serialize,\n\t\tdecode: deserialize\n\t};\n\n\t// Environment detection\n\tif (typeof module === \"object\" && module && typeof module.exports === \"object\") {\n\t\t// Node.js\n\t\tmodule.exports = msgpack;\n\t}\n\telse {\n\t\t// Global object\n\t\twindow[window.msgpackJsName || \"msgpack\"] = msgpack;\n\t}\n\n})();\n";

static const char nt4_js[] = "import \"./msgpack/msgpack.js\";\n\nvar typestrIdxLookup = {\n    NT4_TYPESTR: 0,\n    \"double\": 1,\n    \"int\": 2,\n    \"float\": 3,\n    \"string\": 4,\n    \"json\": 4,\n    \"raw\": 5,\n    \"rpc\": 5,\n    \"msgpack\": 5,\n    \"protobuf\": 5,\n    \"boolean[]\": 16,\n    \"double[]\": 17,\n    \"int[]\": 18,\n    \"float[]\": 19,\n    \"string[]\": 20\n}\n\nclass NT4_TYPESTR{\n    static BOOL = \"boolean\";\n    static FLOAT_64 = \"double\";\n    static INT = \"int\";\n    static FLOAT_32 = \"float\";\n    static STR = \"string\";\n    static JSON = \"json\";\n    static BIN_RAW = \"raw\";\n    static BIN_RPC = \"rpc\";\n    static BIN_MSGPACK = \"msgpack\";\n    static BIN_PROTOBUF = \"protobuf\";\n    static BOOL_ARR = \"boolean[]\";\n    static FLOAT_64_ARR = \"double[]\";\n    static INT_ARR = \"int[]\";\n    static FLOAT_32_ARR = \"float[]\";\n    static STR_ARR = \"string[]\";\n}\n\nexport class NT4_ValReq{\n    prefixes = new Set();\n\n    toGetValsObj(){\n        return {\n            \"prefixes\": Array.from(this.prefixes),\n        };\n    }\n}\n\nexport class NT4_Subscription{\n    prefixes = new Set();\n    options = new NT4_SubscriptionOptions();\n    uid = -1;\n\n    toSubscribeObj(){\n        return {\n            \"prefixes\": Array.from(this.prefixes),\n            \"options\": this.options.toObj(),\n            \"subuid\": this.uid,\n        };\n    }\n\n    toUnSubscribeObj(){\n        return {\n            \"subuid\": this.uid,\n        };\n    }\n}\n\nexport class NT4_SubscriptionOptions {\n    immediate = false;\n    logging = false;\n    periodicRate_s = 0.1;\n\n    toObj(){\n        return {\n            \"immediate\": this.immediate,\n            \"periodic\": this.periodicRate_s,\n            \"logging\": this.logging,\n        };\n    }\n}\n\nexport class NT4_Topic{\n    name = \"\";\n    type = \"\";\n    id = 0;\n    properties = new NT4_TopicProperties();\n\n    toPublishObj(){\n        return {\n            \"name\": this.name,\n            \"type\": this.type,\n        }\n    }\n\n    toUnPublishObj(){\n        return {\n            \"name\": this.name,\n        }\n    }\n\n    toPropertiesObj(){\n        return {\n            \"name\": this.name,\n            \"update\": this.properties.toUpdateObj(),\n        }\n    }\n\n    getTypeIdx(){\n        return typestrIdxLookup[this.type];\n    }\n}\n\nexport class NT4_TopicProperties{\n    isPersistent = false;\n\n    toUpdateObj(){\n        return {\n            \"persistent\": this.isPersistent,\n        }\n    }\n}\n\nexport class NT4_Client {\n\n\n    constructor(serverAddr,\n                onTopicAnnounce_in,    //Gets called when server announces enough topics to form a new signal\n                onTopicUnAnnounce_in,  //Gets called when server unannounces any part of a signal\n                onNewTopicData_in,     //Gets called when any new data is available\n                onConnect_in,          //Gets called once client completes initial handshake with server\n                onDisconnect_in) {     //Gets called once client detects server has disconnected\n\n        this.onTopicAnnounce = onTopicAnnounce_in;\n        this.onTopicUnAnnounce = onTopicUnAnnounce_in;\n        this.onNewTopicData = onNewTopicData_in;\n        this.onConnect = onConnect_in;\n        this.onDisconnect = onDisconnect_in;\n\n        this.subscriptions = new Map();\n        this.subscription_uid_counter = 0;\n\n        this.clientPublishedTopics = new Map();\n        this.serverTopics = new Map();\n\n        this.timeSyncBgEvent = setInterval(this.ws_sendTimestamp.bind(this), 5000);\n\n        // WS Connection State (with defaults)\n        this.serverBaseAddr = serverAddr; \n        this.clientIdx = 0;\n        this.useSecure = false;\n        this.serverAddr = \"\";\n        this.serverConnectionActive = false;\n        this.serverTimeOffset_us = 0;\n\n        // Add default time topic\n        var timeTopic = new NT4_Topic();\n        timeTopic.name = \"Time\";\n        timeTopic.id = -1;\n        timeTopic.type = NT4_TYPESTR.INT; \n        this.serverTopics.set(timeTopic.id, timeTopic);\n    }\n\n    //////////////////////////////////////////////////////////////\n    // PUBLIC API\n\n    // Add a new subscription. Returns a subscription object\n    subscribeImmediate(topicPatterns){\n        var newSub = new NT4_Subscription();\n        newSub.uid = this.getNewSubUID();\n        newSub.options.immediate = true;\n        newSub.options.periodicRate_s = 0;\n        newSub.prefixes = new Set(topicPatterns);\n        newSub.options.logging = false;\n\n        this.subscriptions.set(newSub.uid, newSub);\n        if(this.serverConnectionActive){\n            this.ws_subscribe(newSub);\n        }\n        return newSub;\n    }\n\n    // Add a new subscription. Returns a subscription object\n    subscribePeriodic(topicPatterns, period){\n        var newSub = new NT4_Subscription();\n        newSub.uid = this.getNewSubUID();\n        newSub.options.immediate = false;\n        newSub.options.periodicRate_s = period;\n        newSub.prefixes = new Set(topicPatterns);\n        newSub.options.logging = false;\n\n        this.subscriptions.set(newSub.uid, newSub);\n        if(this.serverConnectionActive){\n            this.ws_subscribe(newSub);\n        }\n        return newSub;\n    }\n\n    // Add a new subscription. Returns a subscription object\n    subscribeLogging(topicPatterns){\n        var newSub = new NT4_Subscription();\n        newSub.uid = this.getNewSubUID();\n        newSub.options.immediate = false;\n        newSub.prefixes = new Set(topicPatterns);\n        newSub.options.logging = true;\n\n        this.subscriptions.set(newSub.uid, newSub);\n        if(this.serverConnectionActive){\n            this.ws_subscribe(newSub);\n        }\n        return newSub;\n    }\n\n    // Requests latest value of a set of topics\n    getValues(topicPatterns){\n        var newValReq = new NT4_ValReq();\n        newValReq.prefixes = new Set(topicPatterns);\n        if(this.serverConnectionActive){\n            this.ws_getvalues(newValReq);\n        }\n    }\n\n    // Given an existing subscription, unsubscribe from it.\n    unSubscribe(sub){\n        this.subscriptions.delete(sub.uid);\n        if(this.serverConnectionActive){\n            this.ws_unsubscribe(sub);\n        }\n    }\n\n    // Unsubscribe from all current subscriptions\n    clearAllSubscriptions(){\n        for(const sub of this.subscriptions.values()){\n            this.unSubscribe(sub);\n        }\n    }\n    \n    // Set the properties of a particular topic\n    setProperties(topic, isPersistent){\n        topic.properties.isPersistent = isPersistent;\n        if(this.serverConnectionActive){\n            this.ws_setproperties(topic);\n        }\n    }\n\n    // Publish a new topic from this client with the provided name and type\n    publishNewTopic(name, type){\n        var newTopic = new NT4_Topic()\n        newTopic.name = name;\n        newTopic.type = type;\n\n        this.clientPublishedTopics.set(newTopic.name, newTopic);\n        if(this.serverConnectionActive){\n            this.ws_publish(newTopic);\n        }\n\n        return newTopic;\n    }\n\n    // UnPublish a previously-published topic from this client.\n    unPublishTopic(oldTopic){\n        this.clientPublishedTopics.delete(oldTopic.name);\n        if(this.serverConnectionActive){\n            this.ws_unpublish(oldTopic);\n        }\n    }\n\n    // Send some new value to the server\n    // Timestamp is whatever the current time is.\n    addSample(topic, value){\n        var timestamp = this.getServerTime_us();\n        this.addSample(topic, timestamp, value);\n    }\n\n    // Send some new timestamped value to the server\n    addSample(topic, timestamp, value){\n\n        if(typeof topic === 'string' ){\n            var topicFound = false;\n            //Slow-lookup - strings are assumed to be topic names for things the server has already announced.\n            for(const topicIter of this.serverTopics.values()){\n                if(topicIter.name === topic){\n                    topic = topicIter;\n                    topicFound = true;\n                    break;\n                }\n            }\n            if(!topicFound){\n                throw \"Topic \" + topic + \" not found in announced server topics!\";\n            }\n        }\n\n        var msg_part_0 = msgpack.serialize(topic.id, {typeHint:\"int\"});\n        var msg_part_1 = msgpack.serialize(timestamp, {typeHint:\"int\"});\n        var msg_part_2 = msgpack.serialize(topic.getTypeIdx(), {typeHint:\"int\"});\n        var msg_part_3 = msgpack.serialize(value, {typeHint:topic.type});\n        \n        var txData = Uint8Array.from([...msg_part_0, \n                                      ...msg_part_1,\n                                      ...msg_part_2,\n                                      ...msg_part_3,\n                                    ]);\n\n        this.ws_sendBinary(txData);\n    }\n\n    //////////////////////////////////////////////////////////////\n    // Server/Client Time Sync Handling\n\n    getClientTime_us(){\n        return new Date().getTime()*1000;\n    }\n\n    getServerTime_us(){\n        return this.getClientTime_us() + this.serverTimeOffset_us;\n    }\n\n    ws_sendTimestamp(){\n        var timeTopic = this.serverTopics.get(-1);\n        if(timeTopic){\n            var timeToSend = this.getClientTime_us();\n            this.addSample(timeTopic, 0, timeToSend);\n            console.log(\"Sending time \" + timeToSend/1000000.0);\n            console.log(\"========================================\");\n        }\n    }\n\n    ws_handleReceiveTimestamp(serverTimestamp, clientTimestamp){\n        var rxTime = this.getClientTime_us();\n\n        console.log(\"Got Response from time \" + clientTimestamp/1000000.0);\n        console.log(\"serverTime = \" + serverTimestamp/1000000.0);\n\n        //Recalculate server/client offset based on round trip time\n        var rtt = rxTime - clientTimestamp;\n        var serverTimeAtRx = serverTimestamp - rtt/2.0;\n        this.serverTimeOffset_us = serverTimeAtRx - rxTime;\n\n        console.log(\"New server time estimate: \" + (this.getServerTime_us()/1000000.0).toString());\n\n\n    }\n\n    //////////////////////////////////////////////////////////////\n    // Websocket Message Send Handlers\n\n    ws_subscribe(sub){\n        this.ws_sendJSON(\"subscribe\", sub.toSubscribeObj());\n    }\n\n    ws_getvalues(gv){\n        this.ws_sendJSON(\"getvalues\", gv.toGetValsObj());\n    }\n\n    ws_unsubscribe(sub){\n        this.ws_sendJSON(\"unsubscribe\", sub.toUnSubscribeObj());\n    }\n\n    ws_publish(topic){\n        this.ws_sendJSON(\"publish\", topic.toPublishObj());\n    }\n\n    ws_unpublish(topic){\n        this.ws_sendJSON(\"unpublish\", topic.toUnPublishObj());\n    }\n\n    ws_setproperties(topic){\n        this.ws_sendJSON(\"setproperties\", topic.toPropertiesObj());\n    }\n\n    ws_sendJSON(method, params){\n        if(this.ws.readyState === WebSocket.OPEN){\n            var txObj = {\n                \"method\": method,\n                \"params\": params\n            }\n            var txJSON = JSON.stringify(txObj);\n            this.ws.send(txJSON);\n        }\n    }\n\n    ws_sendBinary(data){\n        if(this.ws.readyState === WebSocket.OPEN){\n            this.ws.send(data);\n        }\n    }\n\n    //////////////////////////////////////////////////////////////\n    // Websocket connection Maintenance\n\n    ws_onOpen() {\n        \n        // Set the flag allowing general server communication\n        this.serverConnectionActive = true;\n\n        //Publish any existing topics\n        for(const topic of this.clientPublishedTopics.values()){\n            this.ws_publish(topic);\n            this.ws_setproperties(topic);\n        }\n\n        //Subscribe to existing subscriptions\n        for(const sub of this.subscriptions.values()){\n            this.ws_subscribe(sub);\n        }\n\n        // User connection-opened hook\n        this.onConnect();\n    }\n\n    ws_onClose(e) {\n        //Clear flags to stop server communication\n        this.ws = null;\n        this.serverConnectionActive = false;\n\n        // User connection-closed hook\n        this.onDisconnect();\n\n        //Clear out any local cache of server state\n        this.serverTopics.clear();\n\n        console.log('Socket is closed. Reconnect will be attempted in 0.5 second.', e.reason);\n        setTimeout(this.ws_connect.bind(this), 500);\n\n        if(!e.wasClean){\n            console.error('Socket encountered error!');\n            // TODO - based on error, handle the expected ones (secure failure, 409 conflict, etc.) by updating internal state before the next reconnect.\n            this.useSecure = !this.useSecure;\n        }\n\n    }\n\n    ws_onError(e){\n        this.ws.close();\n    }\n\n    ws_onMessage(e){\n        if(typeof e.data === 'string'){\n            //JSON Message\n            var msg = JSON.parse(e.data); \n\n            //Validate proper format of message\n            if(typeof msg !== 'object'){\n                console.log(\"Ignoring text message, JSON parsing did not produce an object.\");\n                return;\n            }\n                \n            if( !(\"method\" in msg) || !(\"params\" in msg)){\n                console.log(\"Ignoring text message, JSON parsing did not find all required fields.\"); \n                return;\n            }\n\n            var method = msg[\"method\"];\n            var params = msg[\"params\"];\n            \n            if(typeof method !== 'string'){\n                console.log(\"Ignoring text message, JSON parsing found \\\"method\\\", but it wasn't a string.\");\n                return;\n            }\n                        \n            if(typeof params !== 'object'){\n                console.log(\"Ignoring text message, JSON parsing found \\\"params\\\", but it wasn't an object.\");\n                return;\n            }\n\n            // Message validates reasonably, switch based on supported methods\n            if(method === \"announce\"){\n                var newTopic = new NT4_Topic();\n                newTopic.name = params.name;\n                newTopic.id = params.id;\n                newTopic.type = params.type;\n                newTopic.properties.isPersistent = params.properties.persistent;\n                this.serverTopics.set(newTopic.id, newTopic);\n                this.onTopicAnnounce(newTopic);\n            } else if (method === \"unannounce\"){\n                var removedTopic = this.serverTopics.get(params.id);\n                if(!removedTopic){\n                    console.log(\"Ignorining unannounce, topic was not previously announced.\");\n                    return;\n                }\n                this.serverTopics.delete(removedTopic.id);\n                this.onTopicUnAnnounce(removedTopic);\n\n            } else {\n                console.log(\"Ignoring text message - unknown method \" + method);\n                return;\n            }\n\n\n        } else {\n            //MSGPack\n            var unpackedData = msgpack.deserialize(e.data, {multiple:true});\n            var topicID = unpackedData[0];\n            var timestamp_us = unpackedData[1];\n            var typeIdx = unpackedData[2];\n            var value   = unpackedData[3];\n\n            if(topicID >= 0){\n                var topic = this.serverTopics.get(topicID);\n                this.onNewTopicData(topic, timestamp_us, value);\n            } else if (topicID === -1){\n                this.ws_handleReceiveTimestamp(timestamp_us, value);\n            } else {\n                console.log(\"Ignoring binary data - invalid topic id \" + topicID.toString());\n            }\n\n        }\n    }\n\n    ws_connect() {\n\n        this.clientIdx = Math.floor(Math.random() * 99999999); //Not great, but using it for now\n\n        var port = 5810; //fallback - unsecured\n        var prefix = \"ws://\";\n        if(this.useSecure){\n            prefix = \"wss://\"; //Use secure if requested.\n            port = 5811;\n        }\n\n        this.serverAddr = prefix + this.serverBaseAddr + \":\" + port.toString() + \"/nt/\" + \"CasseroleWS2_\" + this.clientIdx.toString();\n\n        this.ws = new WebSocket(this.serverAddr, \"networktables.first.wpi.edu\");\n        this.ws.binaryType = \"arraybuffer\";\n        this.ws.onopen = this.ws_onOpen.bind(this);\n        this.ws.onmessage = this.ws_onMessage.bind(this);\n        this.ws.onclose = this.ws_onClose.bind(this);\n        this.ws.onerror = this.ws_onError.bind(this);\n\n        console.log(\"Connected with idx \" + this.clientIdx.toString());\n    }\n    \n\n\n    //////////////////////////////////////////////////////////////\n    // General utilties\n    \n    getNewSubUID(){\n        this.subscription_uid_counter++;\n        return this.subscription_uid_counter + this.clientIdx;\n    }\n\n\n}\n";

static const char test_html[] = "<!DOCTYPE html>\n<html>\n<head/>\n<body>\nJust the bare necessities.\n</body>\n</html>";



// Auto-Generated page response handler.
// Returns poiner to requested content, or null if not available.
void handleHttpFileServe(struct mg_connection *c, struct mg_http_message * hm)
{

   if(mg_http_match_uri(hm, "/FourOhFour.html")) {
      mg_http_reply(c, 200,  header_html,  FourOhFour_html );
      printf("[WEBSERVER] Served /FourOhFour.html\n");
   } else if(mg_http_match_uri(hm, "/index.html")) {
      mg_http_reply(c, 200,  header_html,  index_html );
      printf("[WEBSERVER] Served /index.html\n");
   } else if(mg_http_match_uri(hm, "/main.css")) {
      mg_http_reply(c, 200,  header_css,  main_css );
      printf("[WEBSERVER] Served /main.css\n");
   } else if(mg_http_match_uri(hm, "/main.js")) {
      mg_http_reply(c, 200,  header_js,  main_js );
      printf("[WEBSERVER] Served /main.js\n");
   } else if(mg_http_match_uri(hm, "/msgpack.js")) {
      mg_http_reply(c, 200,  header_js,  msgpack_js );
      printf("[WEBSERVER] Served /msgpack.js\n");
   } else if(mg_http_match_uri(hm, "/nt4.js")) {
      mg_http_reply(c, 200,  header_js,  nt4_js );
      printf("[WEBSERVER] Served /nt4.js\n");
   } else if(mg_http_match_uri(hm, "/test.html")) {
      mg_http_reply(c, 200,  header_html,  test_html );
      printf("[WEBSERVER] Served /test.html\n");
   } else {
      //URL Not found
      printf("[WEBSERVER] Could not find requested resource!\n");
      mg_http_reply(c, 404,  header_html,  FourOhFour_html );
   } 



}